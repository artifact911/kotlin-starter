## Функции высшего порядка
Это функции, которые управляют другими функциями. Функция, которая принимает в себя функцию 
или возвращает функцию является функцией высшего порядка

Когда мы вызываем функцию высшего порядка, в месте ее вызова создается объект анонимного
класса, содержащего данную функцию. Эта операция довольно затратная и если много такого юзать, 
это негативно скажется на перфомансе

Было бы неплохо, чтоб компилятор не создавал объект анонимного класса, а просто вызвал 
функцию иннутри и передал туда значение. И так сделать можно.

inline - добавляем в объявление функции и всё)

Запомнить!!! Если мы создаем небольшой метод, который в качестве параметра принимает функцию, 
то ее следует объявить, как inline

## ООП
### Create class, getter, setter

1. При создании обычного класса можно не указывать явно конструктор. Вместо этого сетается дефолтное значение
2. При обращении к полям, создаются и вызываются подкапотно дефолтные геттеры и сеттеры
    Но можно их пепеопределить, указывая сразу после необходимых полей. Внутри переопределемого геттера 
    или сеттера к полю обращаются через нейминг field

### Constructor
1. Для класса можно создать конструктор - примерно как record в java
    Этот конструктор называется primary

        class Country(val name: String, val population: Long) {
        }

2. Если нам нужен другой констректор, например без параметров, то он пишется явно, используя 
    ключевое слово constructor. Так же при таком синтаксисе мы обязаны вызвать primary 
    конструктор и передать в него дефолтные значения

         class Country(val name: String, val population: Long) {
             constructor() : this("name", 0) {
             }
         }
3. Либо можем отказаться от коструктора из п.2 и засетать в primary конструктор 
   дефолтные значения

         class Country(val name: String = "", val population: Long = 1_000_000) {
         }
4. Если аргументы конструктора val - то они не имеют сеттера. Если var - можно пересеттывать
5. Кроме свойств в конструкторе, объекту можно подкинуть еще свойство филдами. Тут важно понимать, 
    если это свойство - то это будет поле, если поведение, то лучше extension-функция

        class Cat(val name: String, var age: Int, val weight: Float) {

          val isOld: Boolean = age >= 12

          fun printInfo() = println("Кличка: $name, Возраст: $age, Вес: $weight")
          }

val isOld - инициализируется при создании объекта. И если бы даже она была var, то ее значение 
останется неизменным, даже если коту изменить возраст. Но я могу для правильной работы переопределить 
getter для isOld() и тогда он будет работать правильно, даже если isOld val

        class Cat(val name: String, var age: Int, val weight: Float) {

            val isOld: Boolean
                get() = age >= 12

            fun printInfo() = println("Кличка: $name, Возраст: $age, Вес: $weight")