## Функции высшего порядка
Это функции, которые управляют другими функциями. Функция, которая принимает в себя функцию 
или возвращает функцию является функцией высшего порядка

Когда мы вызываем функцию высшего порядка, в месте ее вызова создается объект анонимного
класса, содержащего данную функцию. Эта операция довольно затратная и если много такого юзать, 
это негативно скажется на перфомансе

Было бы неплохо, чтоб компилятор не создавал объект анонимного класса, а просто вызвал 
функцию иннутри и передал туда значение. И так сделать можно.

inline - добавляем в объявление функции и всё)

Запомнить!!! Если мы создаем небольшой метод, который в качестве параметра принимает функцию, 
то ее следует объявить, как inline

## ООП
### Create class, getter, setter

1. При создании обычного класса можно не указывать явно конструктор. Вместо этого сетается дефолтное значение
2. При обращении к полям, создаются и вызываются подкапотно дефолтные геттеры и сеттеры
    Но можно их пепеопределить, указывая сразу после необходимых полей. Внутри переопределемого геттера 
    или сеттера к полю обращаются через нейминг field

### Constructor
1. Для класса можно создать конструктор - примерно как record в java
    Этот конструктор называется primary

        class Country(val name: String, val population: Long) {
        }

2. Если нам нужен другой констректор, например без параметров, то он пишется явно, используя 
    ключевое слово constructor. Так же при таком синтаксисе мы обязаны вызвать primary 
    конструктор и передать в него дефолтные значения

         class Country(val name: String, val population: Long) {
             constructor() : this("name", 0) {
             }
         }
3. Либо можем отказаться от коструктора из п.2 и засетать в primary конструктор 
   дефолтные значения

         class Country(val name: String = "", val population: Long = 1_000_000) {
         }
4. Если артументы конструктора val - то они не имеют сеттера. Если var - можно пересеттывать