## Функции высшего порядка
Это функции, которые управляют другими функциями. Функция, которая принимает в себя функцию 
или возвращает функцию является функцией высшего порядка

Когда мы вызываем функцию высшего порядка, в месте ее вызова создается объект анонимного
класса, содержащего данную функцию. Эта операция довольно затратная и если много такого юзать, 
это негативно скажется на перфомансе

Было бы неплохо, чтоб компилятор не создавал объект анонимного класса, а просто вызвал 
функцию иннутри и передал туда значение. И так сделать можно.

inline - добавляем в объявление функции и всё)

Запомнить!!! Если мы создаем небольшой метод, который в качестве параметра принимает функцию, 
то ее следует объявить, как inline

## ООП
### Create class, getter, setter

1. При создании обычного класса можно не указывать явно конструктор. Вместо этого сетается дефолтное значение
2. При обращении к полям, создаются и вызываются подкапотно дефолтные геттеры и сеттеры
    Но можно их пепеопределить, указывая сразу после необходимых полей. Внутри переопределемого геттера 
    или сеттера к полю обращаются через нейминг field

### Constructor
1. Для класса можно создать конструктор - примерно как record в java
    Этот конструктор называется primary

        class Country(val name: String, val population: Long) {
        }

2. Если нам нужен другой констректор, например без параметров, то он пишется явно, используя 
    ключевое слово constructor. Так же при таком синтаксисе мы обязаны вызвать primary 
    конструктор и передать в него дефолтные значения

         class Country(val name: String, val population: Long) {
             constructor() : this("name", 0) {
             }
         }
3. Либо можем отказаться от коструктора из п.2 и засетать в primary конструктор 
   дефолтные значения

         class Country(val name: String = "", val population: Long = 1_000_000) {
         }
4. Если аргументы конструктора val - то они не имеют сеттера. Если var - можно пересеттывать
5. Кроме свойств в конструкторе, объекту можно подкинуть еще свойство филдами. Тут важно понимать, 
    если это свойство - то это будет поле, если поведение, то лучше extension-функция

        class Cat(val name: String, var age: Int, val weight: Float) {

          val isOld: Boolean = age >= 12

          fun printInfo() = println("Кличка: $name, Возраст: $age, Вес: $weight")
          }

val isOld - инициализируется при создании объекта. И если бы даже она была var, то ее значение 
останется неизменным, даже если коту изменить возраст. Но я могу для правильной работы переопределить 
getter для isOld() и тогда он будет работать правильно, даже если isOld val

        class Cat(val name: String, var age: Int, val weight: Float) {

            val isOld: Boolean
                get() = age >= 12

            fun printInfo() = println("Кличка: $name, Возраст: $age, Вес: $weight")

### Equals
    === - это сравнение ссылок

    == - сравнение объектов - аналог equals()

### Data Class

В таком классе:
1. переопределен toString()
2. переопределен hashCode()
3. переопределен equals()
4. В таком классе есть деструктор - представление объекта в виде набора его переменных

        val student1 = Student("John", "Doe", 42)
        val (name, lastName, id) = student1

        println(name)
        println(lastName)

    теперь мы можем обращаться в этим полям и взаимодействовать с ними так, как нам надо

    Если какая-то переменная в этом наборе нам не нужна, то просто можно поставить _ и ее 
    в наборе не будет

         val (name, lastName, _) = student1

    Деструктор работает благодаря тому, что под капотом класса реализованы компоненты деструктора,
    количество которых равно количеству полей в классе. Все они именуются:
        
         component1()
         component2()
         component3()
         ...

    Можем удалить сейчас data из объявления класса и реализовать эти компоненты сами.
    Для того, чтобы указать, что это функции деструктора, используется ключевое слово operator

         class Student(val name: String, val lastName: String, val id: Int) {
             operator fun component1() = name
             operator fun component2() = lastName
             operator fun component3() = id
        
5. Переопределен метод copy() который вернет новый объект-копию. Можно скопировать как есть,
    а можно переопределить какие-то поля

         val student3 = student2.copy(id = 10)
         val student4 = student2.copy()


### Inheritance

По умолчанию все классы и методы в Котлин final. Для наследования классов и переопределения методов 
в объявлении класса и метода нужно указывать ключевое слово open

        open class Employee(val name: String?, var age: Int?) {

            open fun work() {
                println("Работаю...")
            }
        }

Наследующий класс должен переопределить конструктор родителя

        class Programmer(var lang: String, name: String, age: Int) : Employee(name, age) {

            override fun work() {
                println("Пишу код на $lang")
            }
        }

        По синтаксису:
        - после Programmer открывается коструктор класса Programmer.
        - первым аргументом в данном случае идет поле lang, которого нет у родителя, поэтому 
            оно объявлено по всем правилам: var lang: String
        - Другие поля без var/val, т.к. это поля родителя
        - после конструктора стоит : - именно так указывается наследование
        - после : Employeeсо своим конструктором, куда мы передаем значения, как бы их конструктора
            Programmer

Представим, что у нас в базовом классе поле val, а мы хотели бы в наследнике это поле переписывать
Тогда мы можем это поле переопределить по тем же правилам: возле поля родителя ставим open а в 
наследнике override var

        abstract class Transport10(open val name: String) {
            abstract fun drive()
        }

        class Car10(override var name: String = "Машина") : Transport10(name) {

### SmartCast

it is Cleaner == it instanceOf Cleaner

it as Cleaner == (Cleaner) it


### Abstract class. Interface
Абстрактный класс

    abstract class Worker9(val name: String?, var age: Int?) {

        abstract fun work()
    }

    Почти ничем не отличается от Java. Если есть abstract, open писать необязательно

Интерфейс

    interface Cleaner {
        fun clean()
    }

Имплементации в классе пишутся через запятую

    class Seller9(name: String, age: Int) : Worker9(name, age), Cleaner {

### Anonymous class

Представим, что есть интерфейс или абстрактный класс и нам нужно единожны его реализовать
мы не хотели бы писать целый класс для реализации. Юзаем анонимный класс - ключевое слово
object, потом через : класс, который реализуем

        fun main() {
            travel(object : Transport10("Bus") {
                override fun drive() {
                    println("$name driving")
                }

            })
        }

        fun travel(transport: Transport10) {
            transport.drive()
        }

        Функция travel принимает некую абстракию. 
        Мы из main() пользуемся при помощи анонимного класса

### Модификаторы доступа

private - доступен внутри пакета или файла

public - Доступен везде, установлен по умолчанию

protected - доступне внутри класса и у наследников

internal - доступен внутри модуля(gradle)

### Companion object

В Котлин нет ключевого слово static. Но сама статика никуда не делась. Для ее реализации
используются companion object
Все что создано внутри companion object является аналогом статики в java и обращаться можно через класс.<>

        class Calc {

            companion object {
                const val PI = 3.14

                fun square(n: Int) = n * n
                fun lengthOfCircle(radius: Float) = 2 * PI * radius
            }
        }